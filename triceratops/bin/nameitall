#!/bin/bash
# nameitall
# changes all files in all subdirs; space 2 underline, uppercase 2 lowercase,  removes dash,&,+,\,!,?, and other exotic symbols.
# since rename uses sed syntax (most of it), it went down pretty easy:D

# defaults
dir='*'
sub='3'
opt=''

case "$#" in # check if arguments are given
    0) echo "usage: nameitall [-h|-a|--spc2und|--upp2low|--remove-special] [dir] [level]"
	echo "try: -h for help"
	exit 0
	;;
esac

case "$*" in # check if options are selected
    -h) # display help message
	echo "file/dir renaming algorith @M"
	echo "usage: nameitall [-h|-a|-spc2und|-upp2low|--remove-special] [--dir=] [--level=]"
	echo "       -h                 displays this text."
	echo "       -a                 changes everything: upp>low,spc>und, removes (-,&,+,\,!,?)."
	echo "       --spc2und           changes just space 2 underline."
	echo "       --upp2low          changes just uppercase 2 lowercase."
	echo "broken!--dir=path/to/dir  select directory 2 begin with, path." # Broken >> line 46-51
	echo "broken!--level=level      select the level of depth (subdirs), number."
	exit 0
	;;
    -a) #select all options
       opt='y/A-Z/a-z/ ; s/[°^!"§\$%&()=?`´\\{}\-\;\,:\ <>|+]/_/g ; s/[\[\]]/_/g ; s/_{2,}/_/g'
       echo "all options selected:"
       echo "space 2 underline, uppercase 2 lowercase, remove special chars"
       ;;
    --spc2und) # select space 2 underline only
       opt='s/\ /_/g ; s/_{2,}/_/g'
       echo "space 2 underline selected"
       ;;
    --upp2low)  # select uppercase 2 lowercase only
       opt='y/A-Z/a-z/'
       echo "uppercase 2 lowercase selected"
       ;;
    --remove-special)  # select remove special chars only
       opt='s/[°^!"§\$%&()=?`´\\{}\-\;\,:<>|+]//g'
       echo "remove special chars selected"
       ;;
#    --dir=*)
#       dir="$"
#       ;;
#    --level=*)
#       sub="$"
#       ;;
esac

echo "dir: start with all files in $dir"
echo "level of depth; go down $sub layer"

# do it
for (( c=1; c<=$sub; c++ ))
do
    echo "[$dir] depth of subdir: $c"
    rename -v "$opt" $dir
    dir=$(echo "$dir""/*") # move on to next layer of subdirs (and so forth...)
done

echo "done"

# rename
# ------
#
# first things first:
# rename seems to use basic sed syntax: sed 's/search/replace/g'
# 's'       means substitute (compare y below)
# 'search'  regular expression pattern search pattern
# 'replace' replacement string
# 'g'       means global (=not only first occurence, but all)
#
# syntax of the line above:
# following sed syntax, rename can handle colon seperated statements!
# so there wont be four piped processes, but one 4 all.
# note that the space between the statements hasnt any effect but 2 makes it human readable;-)
#
# legend:
# 'y/A-Z/a-z/'   > substitutes uppercase 2 lowercase.
# 's/[...]/_/g'  > substitutes any given symbol in between the brackets (regexp). as it would with sed.
#                  althought some of them need escaping: '$\,:-' and space.
# 's/[\[\]]/_/g' > special treatment 4 '[]', again as with sed, i have no clue why it doesnt work in comnbination,
#                  but standalone statement just 2 be sure is ok by me;-)
# 's/_{2,}/_/g'  > wipes out any more underlines than one! again, same syntax as sed (except u dont need argument '-r')
#
#
# same with sed: sed -e 's/\(.*\)/\L\1/ ; s/[symbols]/_/g ; s/[\[\]]//g' -re 's/\_{1,}/_/g'
#
# legend:
# sed -e 's/\(.*\)/\L\1/' > uppercase > lowercase
# sed -e 's/[...]/_/g'    > eliminates any given symbol (except '[]', see below), some have to be escapes '\'
# sed -e 's/[\[\]]//g'    > eliminates '[]'
# sed -re 's/_{1,}/_/g'   > wipes out any more underlines than one.

